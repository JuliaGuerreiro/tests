Design Decisions

- Separation of Concerns: The code is divided into different sections using %{ ... %} and %% delimiters. This separation helps in organizing the code and maintaining modularity. The sections include header file inclusions, global variable declarations, token definitions, non-terminal declarations, grammar rules, and error handling.

- Token and Non-terminal Definitions: Tokens are defined using the %token directive, and non-terminals are defined using the %type directive. Each non-terminal is associated with a specific semantic value type. These definitions help in specifying the types of tokens and non-terminals used in the grammar and facilitate semantic analysis.

- Grammar Rules: The grammar rules define the structure and syntax of the COOL language. They specify how different non-terminals are derived from other non-terminals or tokens. The rules are written in a context-free grammar format and are organized hierarchically based on the language syntax.

- Semantic Actions: Semantic actions are associated with grammar rules and are written between curly braces { ... }. These actions are executed when the corresponding rule is applied during parsing. The actions construct the abstract syntax tree nodes based on the parsed tokens and non-terminals. The constructed nodes represent different language constructs such as classes, features, expressions, etc.

- Error Handling: The yyerror function is called automatically when a parse error occurs. It prints an error message indicating the line number and the encountered token. The function keeps track of the number of errors and terminates the parsing process if the number exceeds a threshold.

- Precedence Declarations: Precedence and associativity of operators are defined using the %left, %right, and %nonassoc directives. These declarations ensure that the parser correctly handles operator precedence and resolves ambiguities in the grammar.

- Use of Bison-generated Variables: The code utilizes variables and macros generated by Bison, such as $$, $1, $2, etc., to represent semantic values and tokens during parsing. These variables are automatically populated by Bison based on the grammar rules and semantic actions.

Bad.cl

The code starts with a comment block that provides instructions on how to execute and test the COOL parser. It suggests using the command coolc bad.cl to see the error messages generated by the official COOL parser and myparser bad.cl to see the error messages generated by a custom parser.

After the comment block, the code defines a class named "A" with empty braces. This class has no errors and serves as an example of correct class declaration.

The code continues with the declaration of a class named "A" again, but this time with an "inherits" clause followed by the identifier "B". This line contains an error because the class "B" is not defined in the code snippet. The error is likely to be reported by the parser.

The next part defines a method named "test" within the class "A". This method contains a let expression that tries to bind the identifiers "i" and "j" to certain types and values. However, the value assigned to "i" is of type "int" instead of "Int" (capital "I"), which violates the type rule. This error is likely to be reported by the parser.

Following that, a method named "test2" is defined within the class "A". This method returns the integer constant 1. This part appears to be correct.

The code proceeds with the declaration of another method named "test3" within the class "A". This method contains a block of expressions. However, there are several errors in this block:

The assignment a = Double + a; tries to add a value of type "Double" to a variable "a" of type "Int". This is a type error.
The assignment C = a + 5; tries to assign a value to an undeclared variable "C". This is likely to be reported as an error.
The expression a * 2; does not have any effect and could be considered an unused expression.
The final expression Int; does not have any effect and appears to be a type identifier that is not used correctly.
The code attempts to define a method named "test4" within the class "A". However, the method definition is incomplete. It lacks a parameter name before the colon ":". This incomplete definition is likely to be reported as an error by the parser.

After the class "A" declaration, the code defines a class named "C" that attempts to inherit from a non-existent class "a". This will likely generate an error.

Next, the code declares a class named "D" that misspells the "inherits" keyword as "inherts". This misspelling is expected to be identified as an error.

The final class declaration is for class "E", which tries to inherit from class "A". However, the closing brace for the class declaration is missing. This error will likely be detected by the parser.

Good.cl

Class "A" has a single method named "ana" that returns an integer. The method performs a let expression and returns the sum of the value of "x" and 3.
Class "BB__" inherits from class "A" but does not add any additional members or methods.

Points that make this code correct and robust

- Modularity: The code is divided into different sections, each serving a specific purpose. It includes sections for header inclusion, external variable declarations, token definitions, non-terminal declarations, grammar rules, and error handling. This modular structure makes the code organized and easy to understand.

- Error Handling: The code includes an yyerror function, which is called automatically by Bison when a parse error is detected. The yyerror function prints an error message indicating the location of the error (filename and line number) and increments the error count. It ensures that parse errors are properly reported and prevents the parser from entering an error cascade by limiting the number of errors to 50.

- Token Definitions: The code defines tokens using %token directives, assigning numeric constants to each token. This ensures that the tokens produced by the lexer (scanner) are correctly recognized by the parser. Tokens are specified for reserved keywords, identifiers, string constants, integer constants, boolean constants, and operators.

- Grammar Rules: The grammar rules define the syntax and semantics of the COOL language. Each rule specifies the structure of a non-terminal symbol in terms of other non-terminals and terminals. The grammar rules are written in a way that reflects the language's syntax and the desired behavior of the program. The rules handle different language constructs such as classes, features (methods and attributes), expressions, and control flow statements.

- Semantic Actions: Within the grammar rules, there are semantic actions that specify what should happen when a particular rule is matched during parsing. These actions construct the abstract syntax tree (AST) nodes corresponding to the parsed constructs. The semantic actions make use of the provided cool-tree.h header file, which likely contains the data structures and functions for building and manipulating the AST.

- Type Definitions: The code uses the %type directive to associate semantic types with non-terminal symbols. These type declarations ensure that the parser generates the correct types of semantic values during parsing. The semantic types are specified based on the expected type of the non-terminal's value in the AST.

- Precedence Declarations: The code includes precedence declarations using %left, %right, and %nonassoc directives. These declarations define the precedence and associativity of operators, ensuring that the parser correctly handles operator precedence and resolves any ambiguities in the grammar.

- Error Recovery: The code includes error productions in some grammar rules, such as | error ';' { yyerrok; }. These error productions allow the parser to recover from certain types of syntax errors and continue parsing the input. The yyerrok function call resets the error status, allowing the parser to resume normal parsing.

- Global Variables: The code declares some global variables, such as ast_root, parse_results, and omerrs. These variables are likely used to store the results of parsing and facilitate subsequent stages of the compilation process, such as semantic analysis and code generation.

- Comments and Documentation: The code includes comments that provide explanations, instructions, and warnings about certain aspects of the code. These comments help developers understand the code's purpose, usage, and limitations.
